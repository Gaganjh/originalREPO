package com.manulife.pension.ps.web.validation.pentest;

import java.util.ArrayList;
import java.util.Collection;
import java.util.TreeSet;

import javax.servlet.http.HttpServletRequest;

import org.apache.commons.lang3.StringUtils;
import org.apache.log4j.Logger;

import com.manulife.pension.content.exception.ContentException;
import com.manulife.pension.ezk.web.ActionForm;
import com.manulife.pension.platform.web.CommonConstants;
import com.manulife.pension.platform.web.CommonErrorCodes;
import com.manulife.pension.ps.web.PsBaseUtil;
import com.manulife.pension.ps.web.Constants;
import com.manulife.pension.ps.web.controller.ContractProfile;
import com.manulife.pension.ps.web.controller.UserProfile;
import com.manulife.pension.ps.web.util.SessionHelper;
import com.manulife.pension.service.contract.valueobject.Contract;
import com.manulife.pension.service.security.Principal;
import com.manulife.pension.service.security.valueobject.UserInfo;
import com.manulife.pension.util.content.GenericException;
import com.manulife.pension.util.content.MessageProvider;
import com.manulife.pension.validator.ValidateCatalogHelper;
import com.manulife.pension.validator.valueobject.ViolationVO;
import com.manulife.pension.validator.ValidateCatalogLaunch;

public class PsValidator1 extends ValidateCatalogLaunch {
   
	private static PsValidator1 theInstance = null;
	private static final Logger logger = Logger.getLogger(PsValidator1.class);
	
	//
	// Instantiate catalog launch upon load.
	//
	static {
		synchronized(PsValidator1.class) {
			PsValidator1.getInstance();
		}
	}

    private PsValidator1(String validateSanitize) {
    	super(validateSanitize, PSW_APPL);
    }

    /**
     * A singleton to obtain application-specific catalog properties and to load a catalog.
     * 
     * @return Catalog API handle.
     */
    public static synchronized PsValidator1 getInstance()  {
        if (theInstance == null) {
        	try {
        		theInstance = new PsValidator1(ValidateCatalogHelper.getInstance().getPenetrationDetectionDirective(PENETRATION_FEATURE_PSW));
        	} catch (Exception e) {
        		logger.error("Exception when trying to instantiate PsValidation(): " + e.toString(), e);
        	}
        }
        return theInstance;
    }
        
    /**
     * Subclass and override this mocked-up method with application-specific error handling.
     * 
     * @param before - Number of errors before sanitation.
     * @param after - Number of errors after sanitation.
     * @param violationKeyType - Violation key types.
     * @param badFields - CSV of violated fields.
     * @param violations - Error/Violations list (i/o) to append application-specific errors.
     * @param request - Current web request.
     * 
     * @return True - if violation exception found, false otherwise.
     */
	@SuppressWarnings({ "rawtypes", "unchecked" })
	protected boolean assignMessageTypeToVoilations(int before, int after, int violationKeyType, String badFields, Collection violations, HttpServletRequest request) {
    	 boolean violationFound = false;
    	 if (after > before && violationKeyType != 0) {
    		 violationFound = true;
    		 GenericException genex = null;
    		 switch (violationKeyType) {
	    		 case ERROR_CODE_WITH_GUI_FIELD_NAME:
                     	genex = new GenericException(CommonErrorCodes.ERROR_PSVALIDATION_WITH_GUI_FIELD_NAME, new Object[] { badFields });
	    		 		break;
	    		 case ERROR_CODE_WITH_GUI_FIELD_NAMES:
                  		genex = new GenericException(CommonErrorCodes.ERROR_PSVALIDATION_WITH_GUI_FIELD_NAMES, new Object[] { badFields });
	    		 		break;
	    		 case ERROR_CODE_WITHOUT_GUI_FIELD_NAME:
                     	genex = new GenericException(CommonErrorCodes.ERROR_PSVALIDATION_WITHOUT_GUI_FIELD_NAME);
	    		 		break;
	    		 case ERROR_CODE_WARNING:
	    		 	    break;
	    		 default:
	    			 	logger.debug("assignMessageTypeToVoilations() has unsupported Violation Key Type: " + violationKeyType);
	    			 	break;
    		 }    		 
    		 //
    		 // Log errors & warnings from the current request into MRL database.
    		 //
             String strMessage = "";
    		 try {
    			 if (genex != null) {
    				 strMessage = MessageProvider.getInstance().getMessage(genex.getErrorCode(), genex.getParams());
    			 }
              }
              catch (ContentException ee) {
            	  if (genex != null) {
            		  strMessage = "Error reading error code: " + genex.getMessage() + " is " + ee.getMessage();
            	  }
              }
              finally {
            	  if (!StringUtils.isBlank(strMessage)) {
            		  logger.debug("Security violation message destined to the GUI: " + strMessage);
            	  }
                  if (violations != null) {
                	  String profileAndContract =  getUserProfileIdAndContract(request);
                	  for (Object e: violations) {
                		  if (e instanceof ViolationVO) {
	                		  ViolationVO v = (ViolationVO) e;
	                		  if (v.isError()) {
	                			  logger.error("ERROR! Security violation detected: " + v.toString() + profileAndContract+" Ip Address: "+request.getRemoteHost());
	                		  }
	                		  else {
	                			  logger.error("WARNING! Security violation suspected: " + v.toString() + profileAndContract+" Ip Address: "+request.getRemoteHost());
	                		  }
                		  }
                	  }
                  }
                  
                  //
                  // For GUI reporting, violations list must contain a single error from the current request.
                  //
                  if (violations != null) {
                	  //
                	  // Prior to sanitation check errors are retained.
                	  //
                	  ArrayList<Object> errors = new ArrayList<Object>();
                	  for (Object e : violations) {
                		  if (!(e instanceof ViolationVO)) {
                			  errors.add(e);
                		  }
                	  }
                	  //
                	  // Only single per current request error is reported to the GUI.
                	  //
                	  if (genex != null) {
                		  errors.add(genex);
                	  }
                	  
                	  //
                	  // Final list of violations contain earlier errors and
                	  // current error (warnings excluded).
                	  //
                	  if (errors.size() > 0) {
                		  violations.clear();
                		  violations.addAll(errors);
                	  }
         		 }
              }
    	}
    	return violationFound;
    }
    
    /**
     * Obtain user profile and contract# to be used for error reporting.
     * 
     * @param request - Current web request.
     * @return CSV text of profile and contract, or empty if not found.
     */
    private String getUserProfileIdAndContract(HttpServletRequest request) {
		String profileIdAndContract = "";
		UserProfile userProfile = SessionHelper.getUserProfile(request);
		
		if (userProfile != null) {
			if (!userProfile.getRole().isInternalUser()) {
				UserInfo tpaUserInfo= (UserInfo) request.getSession(false).getAttribute(Constants.TPA_USER_INFO);
	
				if (tpaUserInfo != null) {
					profileIdAndContract = ", ProfileID :" + tpaUserInfo.getProfileId() + ", Contract# :" + tpaUserInfo.getContactId();
				}
		    }
			else {
				long profileId = 0;
				int contractId = 0;
				Principal pr = userProfile.getPrincipal();
				if (pr != null) {
					profileId = pr.getProfileId();
				}
				ContractProfile cp = userProfile.getContractProfile();
				if (cp != null) {
					Contract cn = cp.getContract();
					if (cn != null) {
						contractId = cn.getContactId();
					}
				}
				profileIdAndContract = ", ProfileID :" + profileId + ", Contract# :" + contractId;
			}
		}
		return profileIdAndContract;
	}    

	/**
	 * Merge back-end and Penetration validations errors.
	 * Apply application-specific error handling.
	 * 
	 * @param perrors  - Penetration violations errors.
	 * @param violations - Back-end validation errors.
	 * @param request -  - Current web request.
	 * @return Amalgamated list of violations.
	 */
     public  Collection<GenericException> amalgamateMessageTypeToVoilations(Collection<GenericException> perrors, Collection<GenericException> violations, HttpServletRequest request) {
    	//
    	// Check if merge required.
        //
    	if ((perrors != null && perrors.size() != 0) && (violations == null || violations.size() == 0)) {
		   return perrors;
		}
		else if (perrors != null && perrors.size() != 0 && violations != null && violations.size() != 0) {
		   violations.addAll(perrors);
		}
    	if (violations == null) {
    		return violations;
    	}

		//
		// Extract, amalgamate and categorize errors.
		//
		String badFields = "";
		int violationKeyType = 0;

		int numGuiNames = 0;
		int numNonGuiNames = 0;
		//
		// Scan for error messages categories.
		//
		TreeSet<String> fieldsNames = new TreeSet<String>();
		for (GenericException o : violations) {
			int errCode = + o.getErrorCode();
			if (errCode == CommonErrorCodes.ERROR_PSVALIDATION_WITH_GUI_FIELD_NAME || 
			    errCode == CommonErrorCodes.ERROR_PSVALIDATION_WITH_GUI_FIELD_NAMES) {
				for (Object so : o.getParams()) {
					String names[] = ((String) so).split(",");
					for (String n : names) {
						int before = fieldsNames.size();
						fieldsNames.add(n.trim());
						if (fieldsNames.size() > before) {
							numGuiNames++;
						}
					}
				}
			}
			else {
				numNonGuiNames++;
			}
		}
		//
		// Combine all messages into one CSV.
		//
		if (numNonGuiNames == 0) {
			if (numGuiNames >= 1) {
				for (String f : fieldsNames) {
					if (badFields.length() == 0) {
						badFields += f;
					} else {
						badFields += ", " + f;
					}
				}
			}
		}
		//
		// Derive CMA key type.
		//
		if (numNonGuiNames > 0) {
			violationKeyType = ERROR_CODE_WITHOUT_GUI_FIELD_NAME;
		} else if (numGuiNames == 1) {
			violationKeyType = ERROR_CODE_WITH_GUI_FIELD_NAME;
		} else if (numGuiNames > 1) {
			violationKeyType = ERROR_CODE_WITH_GUI_FIELD_NAMES;
		}
		//
		// Come up with the resulting message code.
		//
		if (violationKeyType != 0) {
			GenericException genex = null;
			switch (violationKeyType) {
			case ERROR_CODE_WITH_GUI_FIELD_NAME:
				genex = new GenericException(CommonErrorCodes.ERROR_PSVALIDATION_WITH_GUI_FIELD_NAME, new Object[] { badFields });
				break;
			case ERROR_CODE_WITH_GUI_FIELD_NAMES:
				genex = new GenericException(CommonErrorCodes.ERROR_PSVALIDATION_WITH_GUI_FIELD_NAMES, new Object[] { badFields });
				break;
			case ERROR_CODE_WITHOUT_GUI_FIELD_NAME:
				genex = new GenericException(CommonErrorCodes.ERROR_PSVALIDATION_WITHOUT_GUI_FIELD_NAME);
				break;
			default:
				logger.debug("amalgamateMessageTypeToVoilations() has unsupported Violation Key Type: " + violationKeyType);
				break;
			}
			//
			// Log errors & warnings from the current request into MRL database.
			//
			String strMessage = "";
			try {
				if (genex != null) {
					strMessage = MessageProvider.getInstance().getMessage(genex.getErrorCode(), genex.getParams());
				}
			} catch (ContentException ee) {
				if (genex != null) {
					strMessage = "Error reading error code: " + genex.getMessage() + " is " + ee.getMessage();
				}
			} finally {
				if (!StringUtils.isBlank(strMessage)) {
					logger.debug("Security violation message destined to the GUI: " + strMessage);
				}
				if (violations != null) {
					String profileAndContract = getUserProfileIdAndContract(request);
					for (Object e : violations) {
						if (e instanceof ViolationVO) {
							ViolationVO v = (ViolationVO) e;
							if (v.isError()) {
								logger.error("ERROR! Security violation detected: " + v.toString() + profileAndContract);
							} else {
								logger.error("WARNING! Security violation suspected: " + v.toString() + profileAndContract);
							}
						}
					}
				}

				//
				// For GUI reporting, violations list must contain a single
				// error from the current request.
				//
				if (violations != null) {
					ArrayList<GenericException> errors = new ArrayList<GenericException>();
					//
					// Only single per current request error is reported to the
					// GUI.
					//
					if (genex != null) {
						errors.add(genex);
					}
					if (errors.size() > 0) {
						violations.clear();
						violations.addAll(errors);
					}
				}
			}
		}
		return violations;
	}

     /*
      * Validate for PenTest penetration for action PsAutoAction validation.
      */
     @SuppressWarnings("rawtypes")
     public static Collection doValidatePenTestAction(ActionForm form, HttpServletRequest request) {
  		return doValidatePenTestAction(form, request, CommonConstants.ERROR_PAGE);
  	}   
  	
  	@SuppressWarnings("rawtypes")
  	public static Collection doValidatePenTestAction(ActionForm form, HttpServletRequest request, String errRdrct) {
  		return doValidatePenTestActionCore(form, request, errRdrct);
  	}
 
  	/**
 	 * Validate for PenTest penetration for BaseAction validation.
 	 */
  	/*@SuppressWarnings("rawtypes")
 	public static Collection doValidatePenTestAutoAction(Form form,   HttpServletRequest request)  {
  		return doValidatePenTestAutoAction(form,  request, "fatalerror");
  	}

 	@SuppressWarnings("rawtypes")
 	public static Collection doValidatePenTestAutoAction(Form form,   HttpServletRequest request, String errRdrct)  {
 		return doValidatePenTestActionCore(form, request, errRdrct,  true);
 	}*/

 	/**
 	 * Validate against PenTest attack for Action and AutoAction validations.
 	 * 
 	 * @return Collection of errors, if any. Session attributes for errors and navigation set.
 	 */
 	@SuppressWarnings("rawtypes")
  	private static Collection doValidatePenTestActionCore(ActionForm form, HttpServletRequest request, String errRdrct) {
  		ArrayList<GenericException> errors = new ArrayList<GenericException>();
  		if (PsValidator1.getInstance().validateSanitizeCatalogedFormFields(form, errors, request) == false) {
 			request.getSession().setAttribute(PsBaseUtil.ERROR_KEY, errors);
 			
 			request.setAttribute(PsBaseUtil.ERROR_KEY, errors);
 			
 			request.getSession().setAttribute(CommonErrorCodes.ERROR_PSWVALIDATION_MASK, CommonErrorCodes.ERROR_PSWVALIDATION_MASK);
 			request.getSession().setAttribute(CommonConstants.ERROR_RDRCT,((!StringUtils.isBlank(errRdrct)) ? errRdrct : CommonConstants.ERROR_PAGE));
 		}
 		return errors;
  	}

}
